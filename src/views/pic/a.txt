
这种短视频都是时间有限，很多地方都是粗逻的讲一下，没法展开，但是下面的这个课
核心的，影响工资高低的内容 都在里面， 包括业务里面的curd，封装，前端脚手架的开发 ，代码规范制定 
看完后 什么是好的知识，什么是好的教程





使用IntersectionObserver对批量图片加载，滚动下拉加载功能，视频广告做了优化


图片懒加载动画
首屏加载动画
滚动加载动画

使用IntersectionObserver对批量图片加载，滚动下拉加载功能，视频广告做了优化


更好的性能：传统的监听滚动事件方式可能会导致频繁的计算，影响页面性能。
而 IntersectionObserver 是浏览器原生提供的 API，它使用异步执行，可以更高效地监听元素是否进入视口，减少了不必要的计算和性能开销

减少代码复杂性：IntersectionObserver 可以简化代码逻辑。使用传统的方式监听滚动事件需要手动计算元素的位置、判断元素是否进入视口，以及处理滚动事件的节流等。
而通过 IntersectionObserver，只需定义回调函数，在元素进入或离开视口时触发相应操作，大大简化了代码

更精确的可见性控制：IntersectionObserver 提供了更精确的可见性控制。通过设置合适的阈值（threshold），
可以灵活地控制元素与视口的交叉区域达到多少时触发回调。这使得开发者可以根据需求来定义元素何时被认为是进入或离开视口，从而触发相应的操作。


``` javascript

// 创建 IntersectionObserver 实例
const options = {
  root: null,  // 观察的元素和谁交叉  （视口就是null）
  rootMargin: '0px',
  threshold: 0.2  （0-1）// 元素交叉区域达到视口20%时触发回调
};

const observer = new IntersectionObserver(callback, options);

// 定义回调函数
function callback(entries, observer) {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      const element = entry.target;
      element.classList.add('animate'); // 添加动画类或样式，触发动画效果

      observer.unobserve(element); // 停止观察该元素
    }
  });
}

// 找到所有需要触发动画效果的元素
const elements = document.querySelectorAll('.animated-element');

// 将元素添加到 IntersectionObserver 中进行观察
elements.forEach(element => {
  observer.observe(element);
});

```



还有一个api muationobserver

